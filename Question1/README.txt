In dynamic programming, a large problem is broken down to smaller subproblems in an array, etc. The smaller problems are usua;;y repetitive. As such, dynamic programming helps in a way that the same problems do not have to be calculated over and over again. This significantly reduced the time complexity of the program. Time complexities: with dynamic programming (O(n)) and without dynamic programming (O(2^n)). 

For this code, I used a bottom-up approach to calculate the Fibinacci numbers for each n. I used the array fib to store the Fibonacci number at each n value. Starting at base cases fib[0]=0 and fib[0]=1. So whenever a higher fib is called, let's say at fib[5] or fib[6], the lower values are pulled from the array and into the fibonacci() function. 

The makeFunc function creates a new Node and assigns the TypeTag to it. For each Node, we have a left Node and a right Node, who act as children to the parent node. The makeNumber function inserts a number into the created Node. The fibonacci(int n) makes the Fibonacci series of numbers for the value of n given. The calc(Node* node) function uses the node values and the fibonacci() function to perform operations on the series created. At first the function checks if the node is a number node. No operation is done and the number is simply returned. If not, then ADD, MUL amd DIC Type tag is checked. If any of these Type tags matches then the corresponding calculation is performed and the result is stored in the 'value' field. If none of these conditions are met, then the program moves to the fibonacci() function and prints the current node. 
